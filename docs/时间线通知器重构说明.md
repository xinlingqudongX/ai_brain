# 时间线通知器重构说明

## 重构概述

将原有的时间线事件系统重构为基于事件广播的订阅模式，实现了更灵活、解耦的定时任务系统。

## 核心变化

### 1. 架构模式转变

**之前**: 时间线事件直接关联到 Agent
```
TimelineEvent → Agent (一对一)
```

**现在**: 事件广播 + 订阅模式
```
TimelineNotifier → 广播事件 → 订阅的 Agents (一对多)
```

### 2. 数据模型变化

#### 删除的实体
- `TimelineEventEntity` - 旧的时间线事件实体

#### 新增的实体
- `TimelineNotifierEntity` - 时间线通知器

#### 修改的实体
- `AgentEntity` - 添加 `subscribedEvents` 字段

### 3. 工作流程变化

#### 之前的流程
```
1. 创建 TimelineEvent，指定 agentId
2. 到达执行时间
3. 直接执行指定的 Agent
```

#### 现在的流程
```
1. 创建 TimelineNotifier，定义事件名称和 Cron 表达式
2. Agent 配置订阅的事件列表
3. 到达执行时间
4. 查找所有订阅了该事件的 Agent
5. 广播 timeline.event 事件
6. 各 Agent 的监听器接收并处理事件
```

## 技术实现

### 1. 时间线通知器服务

```typescript
@Injectable()
export class TimelineNotifierService implements OnModuleInit {
  // 启动时加载所有启用的通知器
  async onModuleInit() {
    await this.loadAllNotifiers();
  }

  // 注册 Cron 任务
  private registerCronJob(notifier: TimelineNotifierEntity) {
    const job = new CronJob(notifier.cronExpression, async () => {
      await this.broadcastEvent(notifier);
    });
    this.schedulerRegistry.addCronJob(`notifier-${notifier.id}`, job);
    job.start();
  }

  // 广播事件
  private async broadcastEvent(notifier: TimelineNotifierEntity) {
    // 查找订阅了此事件的所有 Agent
    const agents = await this.agentRepository
      .createQueryBuilder('agent')
      .where(':eventName = ANY(agent.subscribedEvents)', { eventName: notifier.eventName })
      .andWhere('agent.isActive = :isActive', { isActive: true })
      .getMany();

    // 广播事件
    for (const agent of agents) {
      this.eventEmitter.emit('timeline.event', {
        eventName: notifier.eventName,
        agent: agent,
        context: notifier.context,
        timestamp: new Date()
      });
    }
  }
}
```

### 2. Agent 订阅配置

```typescript
// Agent 实体
@Entity('agents')
export class AgentEntity {
  @Column({ type: 'jsonb', default: [] })
  subscribedEvents: string[];  // 订阅的事件列表
}

// 创建 Agent 时指定订阅
{
  "name": "数据库维护Agent",
  "subscribedEvents": ["daily.backup", "hourly.monitor"]
}
```

### 3. 事件监听器

```typescript
@Injectable()
export class AgentExecutor {
  @OnEvent('timeline.event')
  async handleTimelineEvent(payload: {
    eventName: string;
    agent: AgentEntity;
    context: any;
    timestamp: Date;
  }) {
    // 处理事件
    await this.processEvent(payload);
  }
}
```

## 优势对比

### 1. 灵活性

**之前**:
- 一个事件只能触发一个 Agent
- 需要为每个 Agent 创建单独的事件

**现在**:
- 一个事件可以触发多个 Agent
- Agent 可以订阅多个事件
- 动态添加/删除订阅

### 2. 解耦性

**之前**:
- 事件和 Agent 紧密耦合
- 修改事件需要考虑 Agent

**现在**:
- 通知器和 Agent 完全解耦
- 通过事件名称松耦合
- 独立管理和扩展

### 3. 可维护性

**之前**:
- 事件逻辑分散在多处
- 难以追踪事件流

**现在**:
- 集中管理通知器
- 清晰的事件流
- 易于调试和监控

### 4. 扩展性

**之前**:
- 添加新功能需要修改现有代码
- 难以支持复杂场景

**现在**:
- 新增事件只需创建通知器
- 新增监听器即可扩展功能
- 支持事件链、条件执行等高级场景

## 使用示例对比

### 之前的方式

```typescript
// 为每个 Agent 创建单独的事件
await timelineService.create({
  agentId: 'agent-1',
  name: '备份任务',
  type: 'scheduled',
  scheduledAt: '2024-12-05T02:00:00Z'
});

await timelineService.create({
  agentId: 'agent-2',
  name: '备份任务',
  type: 'scheduled',
  scheduledAt: '2024-12-05T02:00:00Z'
});
```

### 现在的方式

```typescript
// 创建一个通知器
await timelineNotifierService.create({
  eventName: 'daily.backup',
  description: '每日备份',
  cronExpression: '0 0 2 * * *'
});

// Agent 订阅事件
await agentsService.create({
  name: 'Agent 1',
  subscribedEvents: ['daily.backup']
});

await agentsService.create({
  name: 'Agent 2',
  subscribedEvents: ['daily.backup']
});
```

## 迁移指南

### 1. 数据迁移

如果有现有的 TimelineEvent 数据：

```sql
-- 1. 创建通知器（从现有事件中提取唯一的事件名称）
INSERT INTO timeline_notifiers (id, event_name, description, cron_expression, is_enabled)
SELECT 
  gen_random_uuid(),
  name,
  description,
  -- 根据 type 和 scheduledAt/intervalSeconds 生成 cron 表达式
  CASE 
    WHEN type = 'interval' THEN '0 */' || (interval_seconds / 60) || ' * * * *'
    ELSE '0 0 2 * * *'  -- 默认每天凌晨2点
  END,
  true
FROM timeline_events
GROUP BY name, description, type, interval_seconds;

-- 2. 更新 Agent 的订阅列表
UPDATE agents a
SET subscribed_events = ARRAY(
  SELECT DISTINCT te.name
  FROM timeline_events te
  WHERE te.agent_id = a.id
);

-- 3. 删除旧的事件表（备份后）
-- DROP TABLE timeline_events;
```

### 2. 代码迁移

#### 创建事件

**之前**:
```typescript
await timelineService.create({
  agentId: agentId,
  name: '备份任务',
  type: EventType.SCHEDULED,
  scheduledAt: new Date()
});
```

**现在**:
```typescript
// 1. 创建通知器
await timelineNotifierService.create({
  eventName: 'daily.backup',
  description: '每日备份',
  cronExpression: '0 0 2 * * *'
});

// 2. Agent 订阅事件
await agentsService.update(agentId, {
  subscribedEvents: ['daily.backup']
});
```

#### 事件处理

**之前**:
```typescript
// 在 TimelineService 中直接执行
await this.executeEvent(eventId);
```

**现在**:
```typescript
// 实现事件监听器
@OnEvent('timeline.event')
async handleTimelineEvent(payload) {
  await this.processEvent(payload);
}
```

## API 变化

### 删除的 API
- `POST /timeline/action/create` - 创建时间线事件（旧）
- `POST /timeline/action/execute` - 执行事件（旧）

### 新增的 API
- `POST /timeline/action/create` - 创建时间线通知器（新）
- `POST /timeline/action/trigger` - 手动触发事件（新）

### 修改的 API
- `POST /agents/action/create` - 添加 `subscribedEvents` 字段
- `POST /agents/action/update` - 支持更新 `subscribedEvents`

## 配置变化

### Agent 配置

**之前**:
```json
{
  "name": "Agent",
  "roleIds": ["role-id"]
}
```

**现在**:
```json
{
  "name": "Agent",
  "roleIds": ["role-id"],
  "subscribedEvents": ["event1", "event2"]
}
```

### 通知器配置

**新增**:
```json
{
  "eventName": "daily.backup",
  "description": "每日备份",
  "cronExpression": "0 0 2 * * *",
  "context": {
    "type": "full",
    "priority": "high"
  }
}
```

## 注意事项

### 1. 事件名称规范

建议使用分层命名：
- `daily.*` - 每日事件
- `hourly.*` - 每小时事件
- `weekly.*` - 每周事件
- `monthly.*` - 每月事件

### 2. 订阅管理

- Agent 可以随时修改订阅列表
- 订阅列表为空数组表示不订阅任何事件
- 事件名称区分大小写

### 3. 性能考虑

- 避免创建过多的通知器
- 合理设置 Cron 表达式
- 监控事件处理性能

### 4. 错误处理

- 在事件监听器中添加错误处理
- 记录失败的事件
- 实现重试机制

## 测试建议

### 1. 单元测试

```typescript
describe('TimelineNotifierService', () => {
  it('should broadcast event to subscribed agents', async () => {
    const notifier = await service.create({
      eventName: 'test.event',
      cronExpression: '0 * * * * *'
    });

    const agent = await agentsService.create({
      name: 'Test Agent',
      subscribedEvents: ['test.event']
    });

    await service.triggerEvent(notifier.id);

    // 验证事件被广播
    expect(eventEmitter.emit).toHaveBeenCalledWith('timeline.event', {
      eventName: 'test.event',
      agent: expect.objectContaining({ id: agent.id })
    });
  });
});
```

### 2. 集成测试

```typescript
describe('Timeline Integration', () => {
  it('should execute agent when event is triggered', async () => {
    // 创建通知器
    const notifier = await createNotifier();
    
    // 创建订阅的 Agent
    const agent = await createAgent(['test.event']);
    
    // 触发事件
    await triggerEvent(notifier.id);
    
    // 等待处理
    await sleep(1000);
    
    // 验证 Agent 执行
    expect(agentExecuted).toBe(true);
  });
});
```

## 总结

重构后的时间线通知器系统：

✅ **更灵活**: 支持一对多的事件广播
✅ **更解耦**: 通知器和 Agent 独立管理
✅ **更易扩展**: 新增功能无需修改现有代码
✅ **更易维护**: 清晰的事件流和集中管理
✅ **更强大**: 支持复杂的事件场景

这种设计模式更符合事件驱动架构的最佳实践，为未来的功能扩展提供了良好的基础。
